/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************

-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQC1tZiF2UJFwA3ds4mspvqmxjBIyf5Terq7Xzwkh2QOjUCzW1aD
3r0OQqK/JhiY4NcluzkSnXSasRrY5qxbSsjGElC8VgsW61BsdB3Nh+UCfibO9czb
Y7DIX7pdaIQMiSyUadhasKzTe02c620VeABAjgXizWqbGpjwAeJa6ziHmQIDAQAB
AoGABS3j5wzGQs6ylnsjlXQ8+Lv1bF21jhOVdvnD8Raa139XNMWJtcCHivyDPweK
8/CUsVKg0dMDG9Woej4483EyP8atCdPT9hJQOQX1JNqx8gfQBUrwDr+1ffwFxUyd
hEoomWqWn+bmUcJE9Dpt4JLHfnlV6BS7tN+mOZunQ4ZQHcECQQDyPvxRwdWSRxpQ
sjBee+M2fzcynDpZNI6hLrZ9ouRR88TVCW3WVG4sTF9Hou8rN8tG0XgUJnHpPMmZ
obJdK/z9AkEAwAa3rOFjkkfnfh8IFDI0awFXxKZBsIz8sFOOeHjg/y+M0I3mENve
YCzAvUP7c7HPnTeDB69iSrMjaK5oM6YFzQJAWFtg7PEmVRRaJNTZj5zgYyBDodIZ
9i+VVnUTWv/vB3VCdfHafjKNfNreZeKoGbtgCZSdl7vuEIR7g+3WgOVqgQJAawjT
hMe1KqptvH0rkaZSVXrQI0rQvso3Z0mL1lb6gwNMKEuP+8GyeEU5wcWM+XYZVXbF
0JjP3vdvO0BL0M4v2QJBAI8kcn+nlpVXEOSFdY7njnnzh4LZd9wCDfLWyWNsTWuq
2x5Hf/ZxEzPJKj6OA90Q9CDfvePtVKek9T1VVUQEnRg=
-----END RSA PRIVATE KEY-----

RSA Private-Key: (1024 bit, 2 primes)
modulus:
    00:b5:b5:98:85:d9:42:45:c0:0d:dd:b3:89:ac:a6:
    fa:a6:c6:30:48:c9:fe:53:7a:ba:bb:5f:3c:24:87:
    64:0e:8d:40:b3:5b:56:83:de:bd:0e:42:a2:bf:26:
    18:98:e0:d7:25:bb:39:12:9d:74:9a:b1:1a:d8:e6:
    ac:5b:4a:c8:c6:12:50:bc:56:0b:16:eb:50:6c:74:
    1d:cd:87:e5:02:7e:26:ce:f5:cc:db:63:b0:c8:5f:
    ba:5d:68:84:0c:89:2c:94:69:d8:5a:b0:ac:d3:7b:
    4d:9c:eb:6d:15:78:00:40:8e:05:e2:cd:6a:9b:1a:
    98:f0:01:e2:5a:eb:38:87:99
publicExponent: 65537 (0x10001)
privateExponent:
    05:2d:e3:e7:0c:c6:42:ce:b2:96:7b:23:95:74:3c:
    f8:bb:f5:6c:5d:b5:8e:13:95:76:f9:c3:f1:16:9a:
    d7:7f:57:34:c5:89:b5:c0:87:8a:fc:83:3f:07:8a:
    f3:f0:94:b1:52:a0:d1:d3:03:1b:d5:a8:7a:3e:38:
    f3:71:32:3f:c6:ad:09:d3:d3:f6:12:50:39:05:f5:
    24:da:b1:f2:07:d0:05:4a:f0:0e:bf:b5:7d:fc:05:
    c5:4c:9d:84:4a:28:99:6a:96:9f:e6:e6:51:c2:44:
    f4:3a:6d:e0:92:c7:7e:79:55:e8:14:bb:b4:df:a6:
    39:9b:a7:43:86:50:1d:c1
prime1:
    00:f2:3e:fc:51:c1:d5:92:47:1a:50:b2:30:5e:7b:
    e3:36:7f:37:32:9c:3a:59:34:8e:a1:2e:b6:7d:a2:
    e4:51:f3:c4:d5:09:6d:d6:54:6e:2c:4c:5f:47:a2:
    ef:2b:37:cb:46:d1:78:14:26:71:e9:3c:c9:99:a1:
    b2:5d:2b:fc:fd
prime2:
    00:c0:06:b7:ac:e1:63:92:47:e7:7e:1f:08:14:32:
    34:6b:01:57:c4:a6:41:b0:8c:fc:b0:53:8e:78:78:
    e0:ff:2f:8c:d0:8d:e6:10:db:de:60:2c:c0:bd:43:
    fb:73:b1:cf:9d:37:83:07:af:62:4a:b3:23:68:ae:
    68:33:a6:05:cd
exponent1:
    58:5b:60:ec:f1:26:55:14:5a:24:d4:d9:8f:9c:e0:
    63:20:43:a1:d2:19:f6:2f:95:56:75:13:5a:ff:ef:
    07:75:42:75:f1:da:7e:32:8d:7c:da:de:65:e2:a8:
    19:bb:60:09:94:9d:97:bb:ee:10:84:7b:83:ed:d6:
    80:e5:6a:81
exponent2:
    6b:08:d3:84:c7:b5:2a:aa:6d:bc:7d:2b:91:a6:52:
    55:7a:d0:23:4a:d0:be:ca:37:67:49:8b:d6:56:fa:
    83:03:4c:28:4b:8f:fb:c1:b2:78:45:39:c1:c5:8c:
    f9:76:19:55:76:c5:d0:98:cf:de:f7:6f:3b:40:4b:
    d0:ce:2f:d9
coefficient:
    00:8f:24:72:7f:a7:96:95:57:10:e4:85:75:8e:e7:
    8e:79:f3:87:82:d9:77:dc:02:0d:f2:d6:c9:63:6c:
    4d:6b:aa:db:1e:47:7f:f6:71:13:33:c9:2a:3e:8e:
    03:dd:10:f4:20:df:bd:e3:ed:54:a7:a4:f5:3d:55:
    55:44:04:9d:18
writing RSA key
-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQC1tZiF2UJFwA3ds4mspvqmxjBIyf5Terq7Xzwkh2QOjUCzW1aD
3r0OQqK/JhiY4NcluzkSnXSasRrY5qxbSsjGElC8VgsW61BsdB3Nh+UCfibO9czb
Y7DIX7pdaIQMiSyUadhasKzTe02c620VeABAjgXizWqbGpjwAeJa6ziHmQIDAQAB
AoGABS3j5wzGQs6ylnsjlXQ8+Lv1bF21jhOVdvnD8Raa139XNMWJtcCHivyDPweK
8/CUsVKg0dMDG9Woej4483EyP8atCdPT9hJQOQX1JNqx8gfQBUrwDr+1ffwFxUyd
hEoomWqWn+bmUcJE9Dpt4JLHfnlV6BS7tN+mOZunQ4ZQHcECQQDyPvxRwdWSRxpQ
sjBee+M2fzcynDpZNI6hLrZ9ouRR88TVCW3WVG4sTF9Hou8rN8tG0XgUJnHpPMmZ
obJdK/z9AkEAwAa3rOFjkkfnfh8IFDI0awFXxKZBsIz8sFOOeHjg/y+M0I3mENve
YCzAvUP7c7HPnTeDB69iSrMjaK5oM6YFzQJAWFtg7PEmVRRaJNTZj5zgYyBDodIZ
9i+VVnUTWv/vB3VCdfHafjKNfNreZeKoGbtgCZSdl7vuEIR7g+3WgOVqgQJAawjT
hMe1KqptvH0rkaZSVXrQI0rQvso3Z0mL1lb6gwNMKEuP+8GyeEU5wcWM+XYZVXbF
0JjP3vdvO0BL0M4v2QJBAI8kcn+nlpVXEOSFdY7njnnzh4LZd9wCDfLWyWNsTWuq
2x5Hf/ZxEzPJKj6OA90Q9CDfvePtVKek9T1VVUQEnRg=
-----END RSA PRIVATE KEY-----
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
PKA_HandleTypeDef hpka;

UART_HandleTypeDef huart1;

PCD_HandleTypeDef hpcd_USB_FS;

/* USER CODE BEGIN PV */
uint8_t modulus[]= {0xb5, 0xb5, 0x98, 0x85, 0xd9, 0x42, 0x45, 0xc0, 0x0d, 0xdd, 0xb3, 0x89, 0xac, 0xa6, 0xfa, 0xa6, 0xc6, 0x30, 0x48, 0xc9, 0xfe, 0x53, 0x7a, 0xba, 0xbb, 0x5f, 0x3c, 0x24, 0x87, 0x64, 0x0e, 0x8d, 0x40, 0xb3, 0x5b, 0x56, 0x83, 0xde, 0xbd, 0x0e, 0x42, 0xa2, 0xbf, 0x26, 0x18, 0x98, 0xe0, 0xd7, 0x25, 0xbb, 0x39, 0x12, 0x9d, 0x74, 0x9a, 0xb1, 0x1a, 0xd8, 0xe6, 0xac, 0x5b, 0x4a, 0xc8, 0xc6, 0x12, 0x50, 0xbc, 0x56, 0x0b, 0x16, 0xeb, 0x50, 0x6c, 0x74, 0x1d, 0xcd, 0x87, 0xe5, 0x02, 0x7e, 0x26, 0xce, 0xf5, 0xcc, 0xdb, 0x63, 0xb0, 0xc8, 0x5f, 0xba, 0x5d, 0x68, 0x84, 0x0c, 0x89, 0x2c, 0x94, 0x69, 0xd8, 0x5a, 0xb0, 0xac, 0xd3, 0x7b, 0x4d, 0x9c, 0xeb, 0x6d, 0x15, 0x78, 0x00, 0x40, 0x8e, 0x05, 0xe2, 0xcd, 0x6a, 0x9b, 0x1a, 0x98, 0xf0, 0x01, 0xe2, 0x5a, 0xeb, 0x38, 0x87, 0x99};
uint8_t publicExponent[]={0x00,0x01,0x00,0x01};
uint8_t privateExponent[]={0x05, 0x2d, 0xe3, 0xe7, 0x0c, 0xc6, 0x42, 0xce, 0xb2, 0x96, 0x7b, 0x23, 0x95, 0x74, 0x3c, 0xf8, 0xbb, 0xf5, 0x6c, 0x5d, 0xb5, 0x8e, 0x13, 0x95, 0x76, 0xf9, 0xc3, 0xf1, 0x16, 0x9a, 0xd7, 0x7f, 0x57, 0x34, 0xc5, 0x89, 0xb5, 0xc0, 0x87, 0x8a, 0xfc, 0x83, 0x3f, 0x07, 0x8a, 0xf3, 0xf0, 0x94, 0xb1, 0x52, 0xa0, 0xd1, 0xd3, 0x03, 0x1b, 0xd5, 0xa8, 0x7a, 0x3e, 0x38, 0xf3, 0x71, 0x32, 0x3f, 0xc6, 0xad, 0x09, 0xd3, 0xd3, 0xf6, 0x12, 0x50, 0x39, 0x05, 0xf5, 0x24, 0xda, 0xb1, 0xf2, 0x07, 0xd0, 0x05, 0x4a, 0xf0, 0x0e, 0xbf, 0xb5, 0x7d, 0xfc, 0x05, 0xc5, 0x4c, 0x9d, 0x84, 0x4a, 0x28, 0x99, 0x6a, 0x96, 0x9f, 0xe6, 0xe6, 0x51, 0xc2, 0x44, 0xf4, 0x3a, 0x6d, 0xe0, 0x92, 0xc7, 0x7e, 0x79, 0x55, 0xe8, 0x14, 0xbb, 0xb4, 0xdf, 0xa6, 0x39, 0x9b, 0xa7, 0x43, 0x86, 0x50, 0x1d, 0xc1};
uint8_t plaintext[128]={
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
};

uint8_t encrypted_data[128];
uint8_t decrypted_data[128];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_PKA_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	PKA_ModExpInTypeDef in;
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_PKA_Init();
  MX_USART1_UART_Init();
  MX_USB_PCD_Init();
  /* USER CODE BEGIN 2 */
  //encryption
  in.expSize=sizeof(publicExponent);
  in.OpSize=sizeof(modulus);
  in.pExp=publicExponent;
  in.pMod=modulus;
  in.pOp1=plaintext;
if (HAL_PKA_ModExp(&hpka, &in, 1000) != HAL_OK)
{
	Error_Handler();
}

HAL_PKA_ModExp_GetResult(&hpka, encrypted_data);

MX_GPIO_Init();
  MX_PKA_Init();
  MX_USART1_UART_Init();
  MX_USB_PCD_Init();

  //decryption
  in.expSize=sizeof(privateExponent);
  in.OpSize=sizeof(modulus);
  in.pExp=privateExponent;
  in.pMod=modulus;
  in.pOp1=encrypted_data;
if (HAL_PKA_ModExp(&hpka, &in, 5000) != HAL_OK)
{
	Error_Handler();
}

HAL_PKA_ModExp_GetResult(&hpka, decrypted_data);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Macro to configure the PLL multiplication factor
  */
  __HAL_RCC_PLL_PLLM_CONFIG(RCC_PLLM_DIV1);
  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_MSI);
  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the peripherals clocks
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_USART1
                              |RCC_PERIPHCLK_USB;
  PeriphClkInitStruct.PLLSAI1.PLLN = 24;
  PeriphClkInitStruct.PLLSAI1.PLLP = RCC_PLLP_DIV2;
  PeriphClkInitStruct.PLLSAI1.PLLQ = RCC_PLLQ_DIV2;
  PeriphClkInitStruct.PLLSAI1.PLLR = RCC_PLLR_DIV2;
  PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_USBCLK;
  PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSI;
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE0;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
  /** Enable MSI Auto calibration
  */
  HAL_RCCEx_EnableMSIPLLMode();
}

/**
  * @brief PKA Initialization Function
  * @param None
  * @retval None
  */
static void MX_PKA_Init(void)
{

  /* USER CODE BEGIN PKA_Init 0 */

  /* USER CODE END PKA_Init 0 */

  /* USER CODE BEGIN PKA_Init 1 */

  /* USER CODE END PKA_Init 1 */
  hpka.Instance = PKA;
  if (HAL_PKA_Init(&hpka) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN PKA_Init 2 */

  /* USER CODE END PKA_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_7B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USB Initialization Function
  * @param None
  * @retval None
  */
static void MX_USB_PCD_Init(void)
{

  /* USER CODE BEGIN USB_Init 0 */

  /* USER CODE END USB_Init 0 */

  /* USER CODE BEGIN USB_Init 1 */

  /* USER CODE END USB_Init 1 */
  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USB_Init 2 */

  /* USER CODE END USB_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LD2_Pin|LD3_Pin|LD1_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD2_Pin LD3_Pin LD1_Pin */
  GPIO_InitStruct.Pin = LD2_Pin|LD3_Pin|LD1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pins : B2_Pin B3_Pin */
  GPIO_InitStruct.Pin = B2_Pin|B3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
